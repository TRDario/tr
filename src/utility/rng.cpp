#include "../../include/tr/utility/rng.hpp"
#include <ctime>
#include <random>

std::uint64_t tr::gen_random_seed()
{
	std::random_device rng;
	return rng() ^ std::time(nullptr);
}

tr::xorshiftr_128p::xorshiftr_128p(std::uint64_t seed)
	: state{seed++, seed}
{
	advance();
	advance();
}

std::uint64_t tr::xorshiftr_128p::advance()
{
	uint64_t x = state[0];
	uint64_t y = state[1];
	state[0] = y;
	x ^= x << 23;
	x ^= x >> 17;
	x ^= y;
	state[1] = x + y;
	return x;
}

bool tr::xorshiftr_128p::generate_bool()
{
	// Upper bits of the value generated by advance() have better randomness.
	return advance() >> 63;
}

int tr::xorshiftr_128p::generate_sign()
{
	return generate(2) * 2 - 1;
}

tr::angle tr::xorshiftr_128p::generate_angle()
{
	return turns(generate<float>());
}

tr::angle tr::xorshiftr_128p::generate(angle max)
{
	return rads(generate(max.rads()));
}

tr::angle tr::xorshiftr_128p::generate(angle min, angle max)
{
	TR_ASSERT(min < max, "RNG range minimum must be less than the maximum (Currenly: {:r} !< {:r})", min, max);

	return rads(generate(min.rads(), max.rads()));
}

glm::vec2 tr::xorshiftr_128p::generate_vector(float magnitude)
{
	// Prefer this over generating an angle because trigonometric functions don't produce uniform results across platforms.
	const float sin2{generate<float>()};
	const float sin{std::sqrt(sin2) * generate_sign()};
	const float cos{std::sqrt(1 - sin2) * generate_sign()};
	return {magnitude * cos, magnitude * sin};
}