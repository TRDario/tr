#pragma once
#include "angle.hpp"
#include "macro.hpp"

namespace tr {
	// Generates a random seed.
	std::uint64_t gen_random_seed();

	// Xorshiftr128+ random number generator.
	class xorshiftr_128p {
	  public:
		// Initializes RNG.
		xorshiftr_128p(std::uint64_t seed = gen_random_seed());

		// Advances the RNG and returns a value.
		std::uint64_t advance();

		// Generates a random boolean value.
		bool generate_bool();
		// Generates a random sign (-1 or 1).
		int generate_sign();
		// Generates a random integral value.
		template <std::integral T> T generate();
		// Generates a random integral value in the range [0, max).
		template <std::integral T> T generate(T max);
		// Generates a random integral value in the range [min, max).
		template <std::integral T> T generate(T min, T max);
		// Generates a random floating point value in the range [0, 1).
		template <std::floating_point T> T generate();
		// Generates a random floating point value in the range [0, max).
		template <std::floating_point T> T generate(T max);
		// Generates a random floating point value in the range [min, max).
		template <std::floating_point T> T generate(T min, T max);
		// Generates a random angle value in the range [0tr, 1tr).
		angle generate_angle();
		// Generates a random angle value in the range [0, max).
		angle generate(angle max);
		// Generates a random angle value in the range [min, max).
		angle generate(angle min, angle max);
		// Generates a random vector with a certain magnitude.
		glm::vec2 generate_vector(float magnitude);

	  private:
		// The internal state of the generator.
		std::uint64_t m_state[2];
	};
} // namespace tr

///////////////////////////////////////////////////////////// IMPLEMENTATION //////////////////////////////////////////////////////////////

template <std::integral T> T tr::xorshiftr_128p::generate()
{
	// Upper bits of the value generated by advance() have better randomness.
	return static_cast<T>(advance() >> ((sizeof(advance()) - sizeof(T)) * 4));
}

template <std::integral T> T tr::xorshiftr_128p::generate(T max)
{
	TR_ASSERT(max > 0, "RNG range maximum must be greater than 0 (Currently: {}).", max);

	return static_cast<T>(generate<std::make_unsigned_t<T>>() % max);
}

template <std::integral T> T tr::xorshiftr_128p::generate(T min, T max)
{
	TR_ASSERT(min < max, "RNG range minimum must be less than the maximum (Currenly: {} !< {})", min, max);

	return static_cast<T>(generate<std::make_unsigned_t<T>>() % (max - min) + min);
}

template <std::floating_point T> T tr::xorshiftr_128p::generate()
{
	return static_cast<T>(advance()) / static_cast<T>(std::numeric_limits<std::uint64_t>::max());
}

template <std::floating_point T> T tr::xorshiftr_128p::generate(T max)
{
	return generate<T>() * max;
}

template <std::floating_point T> T tr::xorshiftr_128p::generate(T min, T max)
{
	TR_ASSERT(min < max, "RNG range minimum must be less than the maximum (Currenly: {} !< {})", min, max);

	return generate<T>() * (max - min) + min;
}