#pragma once
#include "macro.hpp"
#include "rng.hpp"

constexpr tr::xorshiftr_128p::xorshiftr_128p(std::uint64_t seed) noexcept
	: _state{seed++, seed}
{
	advance();
	advance();
}

constexpr std::uint64_t tr::xorshiftr_128p::advance() noexcept
{
	uint64_t x = _state[0];
	uint64_t y = _state[1];
	_state[0] = y;
	x ^= x << 23;
	x ^= x >> 17;
	x ^= y;
	_state[1] = x + y;
	return x;
}

constexpr bool tr::randbool(xorshiftr_128p& rng) noexcept
{
	// Upper bits of the value generated by advance() have better randomness.
	return rng.advance() >> 63;
}

constexpr int tr::randsign(xorshiftr_128p& rng) noexcept
{
	return rand(rng, 0, 2) * 2 - 1;
}

template <std::integral T> constexpr T tr::rand(xorshiftr_128p& rng) noexcept
{
	// Upper bits of the value generated by advance() have better randomness.
	return static_cast<T>(rng.advance() >> ((sizeof(rng.advance()) - sizeof(T)) * 4));
}

template <std::integral T> constexpr T tr::rand(xorshiftr_128p& rng, T max) noexcept
{
	TR_ASSERT(max > 0, "RNG range maximum must be greater than 0 (Currently: {}).", max);

	return static_cast<T>(rand<std::make_unsigned_t<T>>(rng) % max);
}

template <std::integral T> constexpr T tr::rand(xorshiftr_128p& rng, T min, T max) noexcept
{
	TR_ASSERT(min < max, "RNG range minimum must be less than the maximum (Currenly: {} !< {})", min, max);

	return static_cast<T>(rand<std::make_unsigned_t<T>>(rng) % (max - min) + min);
}

template <std::floating_point T> constexpr T tr::rand(xorshiftr_128p& rng) noexcept
{
	return static_cast<T>(rng.advance()) / static_cast<T>(std::numeric_limits<std::uint64_t>::max());
}

template <std::floating_point T> constexpr T tr::rand(xorshiftr_128p& rng, T max) noexcept
{
	return rand<T>(rng) * max;
}

template <std::floating_point T> constexpr T tr::rand(xorshiftr_128p& rng, T min, T max) noexcept
{
	TR_ASSERT(min < max, "RNG range minimum must be less than the maximum (Currenly: {} !< {})", min, max);

	return rand<T>(rng) * (max - min) + min;
}

template <tr::specialization_of<tr::angle> T> constexpr T tr::rand(xorshiftr_128p& rng) noexcept
{
	return tr::turns(rand<decltype(T{}.turns())>(rng));
}

template <tr::specialization_of<tr::angle> T> constexpr T tr::rand(xorshiftr_128p& rng, T max) noexcept
{
	return rand<T>(rng) * max.turns();
}

template <tr::specialization_of<tr::angle> T> constexpr T tr::rand(xorshiftr_128p& rng, T min, T max) noexcept
{
	TR_ASSERT(min < max, "RNG range minimum must be less than the maximum (Currenly: {}rad !< {}rad)", min.rads(), max.rads());

	return rand<T>(rng) * (max - min).turns() + min;
}

template <std::floating_point T> glm::tvec2<T> tr::randvec(xorshiftr_128p& rng, T magnitude) noexcept
{
	// Prefer this over generating an angle because trigonometric functions don't produce uniform results across platforms.
	const T sin2{rand<T>(rng)};
	const T sin{std::sqrt(sin2) * randsign(rng)};
	const T cos{std::sqrt(1 - sin2) * randsign(rng)};
	return {magnitude * cos, magnitude * sin};
}